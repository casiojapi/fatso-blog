---
title: "Zero-Knowledge Protocol Exploits & Vulnerabilities"
subtitle: "From Tornado Cash (2019) to the Present"
date: 2026-02-26
description: "A complete technical reference covering circuit bugs, trusted setup failures, soundness breaks, governance attacks, and key compromises."
tags: ["zk", "security", "exploits", "tornado-cash", "zcash", "aztec", "polygon", "starknet"]
---

> A complete technical reference covering circuit bugs · trusted setup failures · soundness breaks · governance attacks · key compromises

---

## Table of Contents

1. [Introduction](#introduction)
2. [Exploit #1 — Tornado Cash: MiMC Hash Circuit Bug (Oct 2019)](#1-tornado-cash--mimc-hash-circuit-bug)
3. [Exploit #2 — Zcash: BCTV14 Trusted Setup Counterfeiting (2018/2019)](#2-zcash--bctv14-trusted-setup-counterfeiting-vulnerability)
4. [Exploit #3 — Dark Forest v0.3: Missing Bit Length Check (2020–2021)](#3-dark-forest-v03--missing-bit-length-check-in-rangeproof-circuit)
5. [Exploit #4 — Aztec 2.0: Nondeterministic Nullifier / Double Spend (2021)](#4-aztec-20--nondeterministic-nullifier--double-spend)
6. [Exploit #5 — Aztec Plonk Verifier: The "0 Bug" (2021)](#5-aztec-plonk-verifier--the-0-bug)
7. [Exploit #6 — Circom-Pairing: Missing Output Check (Succinct Labs Bridge) (2022)](#6-circom-pairing--missing-output-check-constraint)
8. [Exploit #7 — "Frozen Heart": Fiat-Shamir Bug in Bulletproofs, PlonK, Girault (Apr 2022)](#7-frozen-heart--fiat-shamir-vulnerability-in-bulletproofs-plonk--girault)
9. [Exploit #8 — PSE & Scroll zkEVM: Missing Modulo Constraint (2022)](#8-pse--scroll-zkevm--missing-modulo-constraint)
10. [Exploit #9 — Polygon zkEVM: Multiple Critical Circuit Vulnerabilities — Hexens Audit (Feb 2023)](#9-polygon-zkevm--multiple-critical-vulnerabilities-hexens-audit)
11. [Exploit #10 — Tornado Cash: Governance Takeover (May 2023)](#10-tornado-cash--governance-takeover-attack)
12. [Exploit #11 — Polygon zkEVM: STARK/SNARK Field Incompatibility (Dec 2023)](#11-polygon-zkevm--starksnark-field-incompatibility)
13. [Exploit #12 — ZK Email: Under-Constrained Circuit / Email Spoofing (2023)](#12-zk-email--under-constrained-circuit--email-address-spoofing)
14. [Exploit #13 — Tornado Cash: Malicious IPFS Frontend (Feb 2024)](#13-tornado-cash--malicious-ipfs-frontend--deposit-data-leak)
15. [Exploit #14 — ZKSync Airdrop: Compromised Admin Key (Apr 2025)](#14-zksync-airdrop--compromised-admin-key)
16. [Vulnerability Taxonomy](#taxonomy-of-zk-vulnerabilities)
17. [Quick Reference Table](#quick-reference-table)
18. [Key Resources](#key-resources)

---

## Introduction

This document catalogs every major exploit, vulnerability, and cryptographic weakness found in **zero-knowledge (ZK) proof protocols** deployed on public blockchains — from the first known ZK circuit bug in Tornado Cash (October 2019) through 2025.

Each entry specifies the nature of the vulnerability — whether it was a **circuit-level bug** (the most cryptographically interesting category), a **smart contract bug** in a ZK protocol, a **trusted setup failure**, a **soundness break** in a proof system implementation, or an **operational security failure**.

### Vulnerability Type Key

| Tag | Meaning |
|-----|---------|
| `CIRCUIT` | Bug in the ZK circuit/constraint system (R1CS, Plonkish) — the deepest cryptographic layer |
| `PROOF SYSTEM` | Vulnerability in the ZK proof system implementation (Fiat-Shamir, Groth16, PLONK) |
| `TRUSTED SETUP` | Leaked or malformed trusted setup parameters |
| `SMART CONTRACT` | Bug in the Solidity on-chain verifier or surrounding contract logic |
| `GOVERNANCE` | Governance manipulation of a ZK protocol's DAO |
| `OPSEC` | Operational security failure (compromised keys, admin access) |

---

## 1. Tornado Cash — MiMC Hash Circuit Bug

| Field | Detail |
|-------|--------|
| **Date** | October 2019 |
| **Protocol** | Tornado Cash (privacy mixer) |
| **Chain** | Ethereum |
| **Type** | `CIRCUIT` — Assigned but not constrained (ZK circuit bug) |
| **Funds at Risk** | All TVL in the mixer |
| **Funds Stolen** | None — Tornado Cash team self-exploited to drain & migrate |
| **Discovered By** | Kobi Gurkan (later Chief Scientist at Aztec) |

### The Vulnerability

Tornado Cash uses zk-SNARKs (Groth16 over BN254) to let users deposit and withdraw ETH with broken on-chain linkability. When depositing, a user commits a secret *note* into a Merkle tree. When withdrawing, they prove knowledge of a note in the tree without revealing which one.

The Merkle tree was computed using the **MiMC hash function**, implemented in Circom. In Circom, there are two critically different operators:

```
<==   (constraint AND assignment — what you want in circuits)
= or <--   (assignment only — does NOT add a constraint to the R1CS)
```

In the MiMC circomlib implementation used by Tornado Cash, the hash output signal was **assigned** using `=` instead of `<==`. This meant the output was set during witness generation but **never constrained during proof verification**.

An attacker could therefore:
- Set an **arbitrary fake Merkle root** in the witness
- Generate a valid-looking zk-SNARK proof (since the hash output wasn't constrained)
- Submit the proof to **withdraw ETH from the contract without having made a deposit**

### The Fix

Change `=` to `<==`. **Two characters.** The Tornado Cash team discovered the bug, immediately self-exploited (white hat) to drain all user funds into a patched contract — preserving user anonymity — and migrated. A remarkable operation.

### References
- [Tornado Cash self-disclosure (Oct 12, 2019)](https://tornado-cash.medium.com/tornado-cash-got-hacked-by-us-b1e012a3c9a8)
- [Trail of Bits: "It pays to be Circomspect"](https://blog.trailofbits.com/2022/09/15/it-pays-to-be-circomspect/)
- [0xPARC Bug Tracker #14](https://github.com/0xPARC/zk-bug-tracker#14-mimc-hash-assigned-but-not-constrained)

---

## 2. Zcash — BCTV14 Trusted Setup Counterfeiting Vulnerability

| Field | Detail |
|-------|--------|
| **Date** | Discovered ~2018, disclosed publicly February 2019 (CVE-2019-7167) |
| **Protocol** | Zcash (privacy cryptocurrency, Sprout pool) |
| **Chain** | Zcash mainnet (own L1) |
| **Type** | `TRUSTED SETUP` — Toxic waste leak in BCTV14, enabling proof forgery |
| **Funds at Risk** | **Unlimited** — any attacker who found this could mint infinite shielded ZEC |
| **Funds Stolen** | None confirmed — impossible to audit (shielded pool is private by design) |
| **Discovered By** | Ariel Gabizon (Electric Coin Company) |

### The Vulnerability

Zcash's original Sprout shielded pool used a proving system based on the **BCTV14** construction (a variant of the Pinocchio/PGHR13 zk-SNARK). The critical security assumption of these systems is a **trusted setup ceremony** — a multi-party computation (MPC) where participants collectively generate proving and verification keys, then destroy their secret contributions ("**toxic waste**").

Ariel Gabizon discovered a flaw in the mathematical construction described in the BCTV14 paper: the key generation procedure, in step 3, produces certain **polynomial evaluation elements that are superfluous** — included by mistake. However, their presence **breaks the soundness** of the proof system. Specifically:

> These extra elements allow a cheating prover to transform a proof for one statement into a valid-looking proof of a **different, arbitrary statement**, without knowing the underlying secrets.

In Zcash terms: an attacker with these parameters could **forge shielded transaction proofs and mint ZEC tokens out of thin air**. The total ZEC supply could be silently inflated without detection, since shielded transactions hide amounts.

### Why This Is Cryptographically Special

This is a **soundness violation at the proof system level** — not a circuit bug or smart contract bug. It means the mathematical guarantee that *"a valid proof implies a valid statement"* was broken at its mathematical foundation. The BCTV14 construction itself was unsound.

### The Fix

Zcash kept the vulnerability secret for ~7 months and fixed it with the **Sapling network upgrade** (October 2018), which introduced a new trusted setup ceremony with 90+ participants and switched to **Groth16**, which is not susceptible to this attack.

### References
- [Zcash official security notice](https://z.cash/blog/zcash-counterfeiting-vulnerability-successfully-remediated/)
- [CVE-2019-7167](https://nvd.nist.gov/vuln/detail/CVE-2019-7167)
- [0xPARC Bug Tracker #13](https://github.com/0xPARC/zk-bug-tracker#13-zcash-trusted-setup-leak)
- [a16z: On-Chain Trusted Setup Ceremony (context)](https://a16zcrypto.com/posts/article/on-chain-trusted-setup-ceremony/)

---

## 3. Dark Forest v0.3 — Missing Bit Length Check in RangeProof Circuit

| Field | Detail |
|-------|--------|
| **Date** | 2020–2021 (early game deployment) |
| **Protocol** | Dark Forest (on-chain ZK strategy game) |
| **Chain** | Ethereum / xDai (Gnosis Chain) |
| **Type** | `CIRCUIT` — Under-constrained circuit; missing bit-length check on inputs |
| **Funds Stolen** | N/A (game, not financial protocol — but game state could be manipulated freely) |
| **Discovered By** | Daira Hopwood (ECC cryptographer) |

### The Vulnerability

Dark Forest uses ZK proofs to hide players' exact coordinates while allowing valid game moves to be verified on-chain. A `RangeProof` circuit was used to prevent position overflows.

The circuit used the circomlib `LessThan` template, which takes a maximum number of bits as a parameter. However, the inputs `max_abs_value` and `in` were **never actually constrained** to that number of bits — `LessThan` uses an `assert()` (only checked at JS simulation time), NOT an R1CS constraint.

```circom
// VULNERABLE: no R1CS constraint on input bit-widths
template RangeProof(bits, max_abs_value) {
    signal input in;
    component lowerBound = LessThan(bits);
    component upperBound = LessThan(bits);
    lowerBound.in[0] <== max_abs_value + in;
    // ...
}
```

An attacker could supply inputs with more bits than expected, causing `LessThan` to compute an incorrect result and satisfy the `RangeProof` even for **out-of-range inputs** — enabling cheating to any coordinate in the game.

### The Fix

Add explicit `Num2Bits` constraints on the inputs, forcing them to actually be the expected number of bits at the R1CS level.

### References
- [0xPARC Bug Tracker #1](https://github.com/0xPARC/zk-bug-tracker#1-dark-forest-v03-missing-bit-length-check)
- [Dark Forest circuit explanation](https://blog.zkga.me/df-init-circuit)

---

## 4. Aztec 2.0 — Nondeterministic Nullifier / Double Spend

| Field | Detail |
|-------|--------|
| **Date** | 2021 (found internally before exploitation) |
| **Protocol** | Aztec Protocol 2.0 (ZK privacy L2) |
| **Chain** | Ethereum (L2) |
| **Type** | `CIRCUIT` — Nondeterministic nullifier; missing 32-bit constraint on note index |
| **Funds at Risk** | All TVL in Aztec 2.0 — any note could be double-spent |
| **Funds Stolen** | None — discovered internally by Aztec team |
| **Discovered By** | Aztec team |

### The Vulnerability

Aztec's privacy protocol represents user funds as **note commitments** stored in an on-chain Merkle tree. To spend a note, users prove ownership and post a **nullifier** — a deterministic value that prevents the same note from being spent twice.

The nullifier was computed as a function of the **note's index** in the Merkle tree. The circuit assumed this index to be a 32-bit number, but **there was no R1CS constraint enforcing this**. An attacker could provide a value with the same lower 32 bits as the real index, but with **additional bits set in higher positions** — producing a different nullifier for the same note commitment.

Because the nullifier was **nondeterministic** (the same note could produce multiple valid-looking nullifiers), an attacker could **spend the same note multiple times**, each time with a different large number whose lower 32 bits matched the real index.

### The Fix

Add a `Num2Bits(32)` constraint on the note index, enforcing it is actually within 32 bits.

### References
- [0xPARC Bug Tracker #6](https://github.com/0xPARC/zk-bug-tracker#6-aztec-20-missing-bit-length-check--nondeterministic-nullifier)

---

## 5. Aztec Plonk Verifier — The "0 Bug"

| Field | Detail |
|-------|--------|
| **Date** | 2021 (found by Aztec team before exploitation) |
| **Protocol** | Aztec Protocol — Plonk verifier contract |
| **Chain** | Ethereum |
| **Type** | `PROOF SYSTEM` — Edge case accepting a degenerate zero-proof |
| **Funds at Risk** | All TVL in Aztec |
| **Funds Stolen** | None — found internally |
| **Discovered By** | Aztec team |

### The Vulnerability

In Aztec's Plonk verifier, there was an edge case where **a proof where all values are the zero element** would pass verification. The verifier had no check preventing a trivial zero-proof from being accepted.

PlonK verification involves polynomial commitments and elliptic curve pairings. A proof consisting entirely of the identity element (zero / point at infinity in the relevant groups) could satisfy the pairing checks **vacuously or trivially** — the pairing equations held not because the witness was valid, but because the mathematical structure collapsed to a trivially satisfied identity.

An attacker could construct this degenerate proof and use it to **make arbitrary withdrawals from Aztec** without having a valid note commitment. Complete break of soundness.

### References
- [0xPARC Bug Tracker #7](https://github.com/0xPARC/zk-bug-tracker#7-aztec-plonk-verifier-0-bug)

---

## 6. Circom-Pairing — Missing Output Check Constraint

| Field | Detail |
|-------|--------|
| **Date** | 2022 (pre-deployment audit by Veridise) |
| **Protocol** | Circom-Pairing — used in Succinct Labs' cryptographic bridge |
| **Chain** | Ethereum (bridge) |
| **Type** | `CIRCUIT` — Under-constrained outputs; range-check results never validated |
| **Funds at Risk** | Potentially all bridge TVL |
| **Funds Stolen** | None — caught by Veridise before deployment |
| **Discovered By** | Veridise Team |

### The Vulnerability

The Circom-Pairing circuits implement **BLS12-381 elliptic curve pairing verification**, used for light client bridges that verify consensus signatures from one chain on another.

Because BLS12-381 field elements are larger than the circom prime field (~254 bits), numbers are represented as `k`-length arrays of `n`-bit chunks. A `BigLessThan` circuit was used to enforce that `pubkey < BLS12-381 prime q`. Ten instances of this check were instantiated. However, **the OUTPUT signals of these `BigLessThan` circuits were never constrained to equal 1**:

```circom
// VULNERABLE: lt[i] computed but output never checked
component lt[10];
for(var i=0; i<10; i++){
    lt[i] = BigLessThan(n, k);
    // ... inputs wired ...
}
// ❌ MISSING: lt[i].out === 1
```

An attacker could supply pubkeys `≥ q`, breaking the mathematical assumptions of pairing-based cryptography and potentially allowing **fraudulent bridge proofs** to be accepted.

### The Fix

```circom
var r = 0;
for(var i=0; i<10; i++){ r += lt[i].out; }
r === 10;
```

Veridise estimated this was a **million-dollar bug** caught before deployment.

### References
- [Veridise article: "A Million Dollar ZK Bug Caught Early"](https://medium.com/veridise/circom-pairing-a-million-dollar-zk-bug-caught-early-c5624b278f25)
- [0xPARC Bug Tracker #3](https://github.com/0xPARC/zk-bug-tracker#3-circom-pairing-missing-output-check-constraint)

---

## 7. "Frozen Heart" — Fiat-Shamir Vulnerability in Bulletproofs, PlonK & Girault

| Field | Detail |
|-------|--------|
| **Date** | Disclosed April 13, 2022 (coordinated disclosure by Trail of Bits) |
| **Protocol** | ING Bank zkrp · SECBIT Labs ckb-zkp · Adjoint bulletproofs · ZenGo · Dusk Network plonk · Iden3 SnarkJS · ConsenSys gnark |
| **Chain** | Multiple (Ethereum, CKB, others) |
| **Type** | `PROOF SYSTEM` — Insecure Fiat-Shamir transformation enabling proof forgery |
| **Funds at Risk** | Any protocol using these vulnerable proof systems |
| **Funds Stolen** | None confirmed — Trail of Bits performed responsible disclosure |
| **Discovered By** | Trail of Bits (Jim Miller) |

### The Vulnerability — Deep Technical Explanation

**Frozen Heart** is a class of vulnerability in ZK proof systems that use the **Fiat-Shamir transformation** — the technique that converts interactive ZK protocols into non-interactive ones by replacing the verifier's random challenges with hash outputs.

The security of Fiat-Shamir requires that the hash computation include **ALL public values** from the proof statement AND all public commitment values generated during the proof. Omitting *any* public value allows a malicious prover to **manipulate the challenge values**, breaking soundness.

#### Bulletproofs (Range Proofs)

```
INSECURE (from the original paper):
  y = Hash(A, S)
  z = Hash(A, S, y)
  x = Hash(A, S, y, z, T1, T2)

SECURE:
  y = Hash(g, h, V, n, A, S)   ← V is the Pedersen commitment to the secret value
  z = Hash(..., y)
  x = Hash(..., z, T1, T2)
```

The critical missing value is **V** — the Pedersen commitment `V = g^v * h^γ`, where `v` is the secret value being range-proved. Without `V` in the hash, an attacker can:

1. Choose any out-of-range value `v` (e.g., -1, or a 256-bit integer when claiming `[0, 2^32)`)
2. Manipulate the challenge `y` to forge a valid-looking proof
3. The verifier accepts the proof, believing the value is in-range

This is a complete soundness break for any protocol using Bulletproofs for range verification (privacy coins, DeFi collateral checks, etc.).

#### PlonK (affecting Dusk Network, Iden3 SnarkJS, ConsenSys gnark)

In PlonK's round 3, the **evaluation challenge `zeta`** is computed using Fiat-Shamir. These implementations failed to include the **public inputs** in the transcript before computing `zeta`. Without public inputs bound to the challenge, a prover can forge proofs for arbitrary statements.

#### Affected Implementations

| Library | System | Status |
|---------|--------|--------|
| ING Bank zkrp | Bulletproofs | Repository deleted |
| SECBIT Labs ckb-zkp | Bulletproofs | Could not contact |
| Adjoint Inc. bulletproofs | Bulletproofs | Could not contact |
| ZenGo | Girault's proof of knowledge | Patched |
| Dusk Network plonk | PlonK | Patched |
| Iden3 SnarkJS | PlonK | Patched |
| ConsenSys gnark | PlonK | Patched |
| Original Bulletproofs paper | Bulletproofs | Authors updated paper |

### References
- [Trail of Bits — Part 1 (Coordinated Disclosure)](https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/)
- [Trail of Bits — Frozen Heart in Bulletproofs](https://blog.trailofbits.com/2022/04/15/the-frozen-heart-vulnerability-in-bulletproofs/)
- [Trail of Bits — Frozen Heart in PlonK](https://blog.trailofbits.com/2022/04/18/the-frozen-heart-vulnerability-in-plonk/)

---

## 8. PSE & Scroll zkEVM — Missing Modulo Constraint

| Field | Detail |
|-------|--------|
| **Date** | 2022 (found during audits, pre-mainnet) |
| **Protocol** | Privacy and Scaling Explorations (PSE) & Scroll zkEVM |
| **Chain** | Ethereum (ZK rollup) |
| **Type** | `CIRCUIT` — Missing constraint in modulo gadget; false state transitions possible |
| **Funds at Risk** | All L2 funds if deployed |
| **Funds Stolen** | None — found pre-deployment |
| **Discovered By** | Internal team / auditors |

### The Vulnerability

The PSE & Scroll zkEVM is programmed using a fork of Zcash's **Halo2** proof system. The zkEVM circuit is divided into **gadgets** — self-contained subcircuits for common operations. The **modulo operation gadget** was missing a constraint.

Without the full constraint, a malicious prover could create a valid proof of a **false modulo operation** — e.g., proving `10 mod 3 = 99`. Since modulo is a building block for many EVM opcodes, this could allow the prover to convince the Ethereum L1 verifier of a **completely fabricated zkEVM state transition**, stealing all L2 funds.

### References
- [0xPARC Bug Tracker #16](https://github.com/0xPARC/zk-bug-tracker#16-pse--scroll-zkevm-missing-constraint)

---

## 9. Polygon zkEVM — Multiple Critical Vulnerabilities (Hexens Audit)

| Field | Detail |
|-------|--------|
| **Date** | Disclosed February 27, 2023 (pre-mainnet) |
| **Protocol** | Polygon zkEVM |
| **Chain** | Ethereum (ZK rollup) |
| **Type** | `CIRCUIT` + `SMART CONTRACT` — 4 critical vulnerabilities in PIL/zkASM constraint system |
| **Funds at Risk** | All L2 TVL if deployed |
| **Funds Stolen** | None — all fixed before mainnet launch |
| **Discovered By** | Hexens security team + Spearbit (parallel audit) |

### Critical Findings

Hexens audited Polygon zkEVM's client stack including the RPC node, sequencer, aggregator, **PIL** (Polynomial Identity Language), and bridge contracts. Four critical vulnerabilities were found:

**1. Missing PIL Constraint → Fake Inclusion in Sparse Merkle Tree (SMT)**
A missing constraint in PIL allowed a prover to generate a valid-looking proof of inclusion for a value that wasn't actually in the state tree. Attacker could lie about account balances or storage slots.

**2. Incorrect CTX Assignation → Sequencer ETH Inflation**
A bug in the context assignment logic could allow a dishonest sequencer to **silently add arbitrary ETH to its own balance** in the L2 state — effectively minting money.

**3. Missing Constraint → Execution Flow Hijack**
A PIL-level missing constraint allowed a malicious prover to **redirect the execution flow of the zkEVM** — executing different code than what was committed to. Arbitrary code execution in the L2.

**4. ecrecover Discrepancy in zkASM**
A difference between `ecrecover` in zkASM vs. the standard EVM allowed proofs to be generated for **transactions with invalid signatures**.

Spearbit, auditing in parallel, found **10 critical + 1 high** additional vulnerabilities in the ROM and zkASM. All fixed before mainnet.

### References
- [Hexens Audit Report (public PDF)](https://github.com/0xPolygonHermez/zkevm-rom/blob/main/audits/Hexens_Polygon_zkEVM_PUBLIC_27.02.23.pdf)
- [Polygon announcement](https://polygon.technology/blog/polygon-zkevm-results-of-hexens-security-audit)
- [0xPARC Bug Tracker #21–23](https://github.com/0xPARC/zk-bug-tracker#21-polygon-zkevm-missing-constraint-in-pil-leading-to-proving-fake-inclusion-in-the-smt)

---

## 10. Tornado Cash — Governance Takeover Attack

| Field | Detail |
|-------|--------|
| **Date** | May 20, 2023 |
| **Protocol** | Tornado Cash (DAO governance layer) |
| **Chain** | Ethereum |
| **Type** | `GOVERNANCE` / `SMART CONTRACT` — CREATE2 + SELFDESTRUCT contract morphing |
| **Funds Stolen** | ~$1M in TORN tokens + full governance control |
| **Discovered By** | samczsun (Paradigm) — post-hoc |

### The Vulnerability

> Note: NOT a ZK circuit exploit. A governance attack on the DAO controlling Tornado Cash. Included for completeness since it directly affected a major ZK protocol.

The attacker exploited a combination of `CREATE2` and `SELFDESTRUCT` opcodes to deploy a **shape-shifting contract**. The attack:

1. Attacker deploys a proposal contract that **appeared identical** to a previously approved legitimate proposal
2. Hidden in the proposal: a function calling `SELFDESTRUCT` (allowing the contract to be deleted and redeployed at the same deterministic address)
3. Community votes for the proposal, trusting it was legitimate
4. After passing, attacker **self-destructs** the proposal contract
5. Using `CREATE2` (deterministic address), attacker **redeploys a different malicious contract** at the same address
6. Governance executes the now-malicious proposal via `delegatecall`
7. **10,000 TORN tokens are assigned per attacker address** → 1.2 million fraudulent votes vs ~700K legitimate
8. With full governance control: ~$1M drained

### References
- [Halborn post-mortem](https://www.halborn.com/blog/post/explained-the-tornado-cash-hack-may-2023)
- [Technical walkthrough (Coinmonks)](https://medium.com/coinmonks/tornado-cash-governance-hack-ec77ebb3aa68)

---

## 11. Polygon zkEVM — STARK/SNARK Field Incompatibility

| Field | Detail |
|-------|--------|
| **Date** | Reported mid-2023, fixed December 2023 |
| **Protocol** | Polygon zkEVM |
| **Chain** | Ethereum (ZK rollup) |
| **Type** | `PROOF SYSTEM` — Field size incompatibility between STARK and SNARK in recursive proving pipeline |
| **Funds at Risk** | All L1 deposits and L2 TVL |
| **Funds Stolen** | None — found via Immunefi bug bounty, responsibly disclosed |
| **Discovered By** | Verichains security research team |

### The Vulnerability — Highly Cryptographic

Polygon zkEVM's prover uses **eSTARK** as its primary backend. To reduce Ethereum L1 gas costs, the final proof undergoes **recursive reduction**: the STARK proof is converted into a **Groth16 SNARK** for cheap on-chain verification.

This recursion involves a **critical mathematical incompatibility**:

| System | Field | Size |
|--------|-------|------|
| eSTARK | F_p³ where p = 2^64 - 2^32 + 1 | Goldilocks, 64-bit |
| Groth16 SNARK | F_q (BN254 curve) | 254-bit |

During conversion, **Merkle roots** (FRI-based polynomial commitments) were computed from leaves that are `F_q` elements — but the FRI layer expected `F_p³` elements. This field mismatch created a **soundness gap**:

The SNARK proof system was making claims about STARK computations over an incompatible field, allowing a malicious Trusted Aggregator to:
- Generate a **valid Groth16 proof** that passes Ethereum L1 verification
- But which corresponds to a **fabricated STARK computation / false L2 state**
- Steal any/all funds from the L2 network and L1 bridge

Verichains successfully demonstrated PoC exploits generating **valid counterfeit proofs** for:
- Fork ID 4 (Ethereum mainnet) at block heights 18066976 and 18026062
- Fork ID 5 (Goerli testnet) at block height 9679280

### Why This Is Special

This is one of the most technically sophisticated ZK vulnerabilities ever discovered — a **mathematical incompatibility at the interface between two different proof systems** in a recursive proving pipeline. Not a simple missing constraint, but a fundamental design-level flaw in how STARK and SNARK arithmetization interoperate.

### References
- [Verichains detailed report](https://blog.verichains.io/p/discovering-and-fixing-a-critical)

---

## 12. ZK Email — Under-Constrained Circuit / Email Address Spoofing

| Field | Detail |
|-------|--------|
| **Date** | 2023 (discovered during audit) |
| **Protocol** | ZK Email (circuit library for proving email provenance) |
| **Chain** | Ethereum (applications built on ZK Email) |
| **Type** | `CIRCUIT` — Under-constrained email header parsing allows address spoofing |
| **Funds at Risk** | Any application using ZK Email for identity/authorization |
| **Funds Stolen** | None — found in audit |

### The Vulnerability

ZK Email allows users to prove they own an email address by producing a ZK proof of a **DKIM-signed email** — without revealing the full email contents. Applications use this for identity, account recovery, and DAO voting.

A missing constraint in the email header parsing circuit allowed a malicious prover to manipulate the parsing of the `From:` header. An attacker could:

1. Use a real email from `any@attacker.com` (which they legitimately own)
2. Manipulate the **witness** to claim the `From:` header showed `victim@target.com`
3. Generate a valid-looking proof accepted as proof of the victim's email address
4. Impersonate anyone in any ZK Email-based application

### References
- [0xPARC Bug Tracker #27](https://github.com/0xPARC/zk-bug-tracker#27-zk-email-under-constrained-circuit-leads-to-email-address-spoofing)

---

## 13. Tornado Cash — Malicious IPFS Frontend / Deposit Data Leak

| Field | Detail |
|-------|--------|
| **Date** | Active ~January–February 2024; discovered February 26, 2024 |
| **Protocol** | Tornado Cash (IPFS-hosted frontend) |
| **Chain** | Ethereum |
| **Type** | `SMART CONTRACT` / Supply Chain — Malicious JavaScript in governance proposal |
| **Funds Stolen** | At least 1 deposit confirmed stolen; note data leaked for many others |
| **Discovered By** | Community member "Gas404" |

### The Vulnerability

> Note: Not a ZK circuit exploit. Included as a significant attack on a ZK privacy protocol's operational infrastructure.

On January 1, 2024, a malicious governance proposal was submitted by an alleged Tornado Cash developer. Hidden in the proposal was a **JavaScript snippet embedded in the IPFS-hosted UI**. This code:

- Silently redirected **deposit note data** (which contains the secret preimage for withdrawals) to an attacker-controlled server
- Included functionality to directly steal deposits

The malicious code was active for **~2 months** before community member Gas404 discovered it. All users who deposited during this window had their note data leaked — their deposits could be linked to withdrawals, **permanently destroying their privacy**.

### References
- [CoinDesk original report](https://www.coindesk.com/business/2024/02/26/tornado-cash-reportedly-suffers-backend-exploit-user-deposits-at-risk)

---

## 14. ZKSync Airdrop — Compromised Admin Key

| Field | Detail |
|-------|--------|
| **Date** | April 15, 2025 |
| **Protocol** | ZKSync Era (ZK rollup on Ethereum) |
| **Chain** | Ethereum (L2) |
| **Type** | `OPSEC` — Compromised admin private key controlling airdrop distribution contracts |
| **Funds Stolen** | ~$5M (111 million ZK tokens minted and stolen) |
| **Discovered By** | ZKSync security team |

### The Vulnerability

> Note: NOT a ZK circuit or proof system exploit. Operational security failure. The core ZKSync protocol, proof system, and user funds were completely unaffected.

The ZKSync team had deployed three airdrop distribution contracts, each controlled by a **single admin private key**. An attacker obtained one of these private keys and called the `sweepUnclaimed()` function — designed to allow the admin to recover unclaimed airdrop tokens.

At the time, ~111 million ZK tokens (~$5M) remained unclaimed. The attacker minted all of them to their own address. The exploit was entirely confined to the poorly secured airdrop contracts.

### References
- [Halborn post-mortem](https://www.halborn.com/blog/post/explained-the-zksync-hack-april-2025)

---

## Taxonomy of ZK Vulnerabilities

From most to least cryptographically fundamental:

### 1. Under-Constrained Circuits
The most common class. A signal is **computed** (assigned) but not **constrained** in the R1CS/Plonkish system. During proof generation (witness computation), the value is calculated correctly. But during proof **verification**, only the constraints are checked. A signal assigned with `<--` or `=` instead of `<==` is "free" from the verifier's perspective.

*Examples: Tornado Cash MiMC, Circom-Pairing BigLessThan output, PSE zkEVM modulo gadget, ZK Email header parsing.*

### 2. Nondeterministic Circuits / Missing Bit-Length Checks
A circuit should have exactly one valid witness for any given public input. Without bit-length constraints, multiple witnesses can satisfy the same constraint system — enabling attacks like double-spending (same note → multiple valid nullifiers).

*Examples: Aztec 2.0 nondeterministic nullifier, Dark Forest RangeProof, BigInt missing remainder check.*

### 3. Trusted Setup Failures
For Groth16, PLONK, and BCTV14: if the "toxic waste" (secret trapdoor parameters) is leaked, OR if the ceremony has a mathematical flaw (as in BCTV14), soundness is broken **globally** — every proof made with those parameters can potentially be forged. The Zcash BCTV14 vulnerability is the canonical example.

### 4. Fiat-Shamir Implementation Errors (Frozen Heart)
When interactive ZK proofs are made non-interactive via Fiat-Shamir, the hash transcript must include **all** public values. Omitting any allows a malicious prover to manipulate challenge values and forge proofs. Affected Bulletproofs, PlonK, and Girault implementations across multiple major libraries.

### 5. Proof System Incompatibilities
When combining multiple proof systems (e.g., STARK → SNARK recursion), **field size incompatibilities** can create soundness gaps at the interface. Among the most subtle vulnerabilities because both individual systems can be correct while their composition is not.

*Example: Polygon zkEVM STARK/SNARK field mismatch.*

### 6. Smart Contract Verifier Bugs
Even if the ZK circuit is correct, the on-chain verifier contract may have bugs. Edge cases like the zero-proof (Aztec 0 Bug) or missing range checks on public inputs (Semaphore) can break the protocol at the Solidity layer.

---

## Quick Reference Table

| # | Year | Protocol | Chain | Type | Key Impact | Exploited? |
|---|------|----------|-------|------|------------|------------|
| 1 | Oct 2019 | Tornado Cash | Ethereum | `CIRCUIT` | Fake Merkle root → withdraw without deposit | Self-exploited (white hat) |
| 2 | 2018/2019 | Zcash (Sprout) | Zcash L1 | `TRUSTED SETUP` | Infinite ZEC counterfeiting possible | Not known / unprovable |
| 3 | 2020–21 | Dark Forest v0.3 | Ethereum/xDai | `CIRCUIT` | Invalid coordinate proofs → game cheating | Unknown |
| 4 | 2021 | Aztec 2.0 | Ethereum | `CIRCUIT` | Double-spend via nondeterministic nullifier | No |
| 5 | 2021 | Aztec Plonk | Ethereum | `PROOF SYSTEM` | Zero proof accepted → complete soundness break | No |
| 6 | 2022 | Circom-Pairing | Ethereum | `CIRCUIT` | ~$1M bridge TVL at risk; forged BLS proofs | No |
| 7 | Apr 2022 | Bulletproofs / PlonK | Multiple | `PROOF SYSTEM` | Forged range proofs; 8+ impls affected | No |
| 8 | 2022 | PSE / Scroll zkEVM | Ethereum | `CIRCUIT` | False modulo → false L2 state transitions | No |
| 9 | Feb 2023 | Polygon zkEVM | Ethereum | `CIRCUIT` + PIL | 4 critical: SMT fraud, ETH inflation, hijack | No |
| 10 | May 2023 | Tornado Cash DAO | Ethereum | `GOVERNANCE` | ~$1M stolen; full DAO takeover | Yes — ~$1M |
| 11 | Dec 2023 | Polygon zkEVM | Ethereum | `PROOF SYSTEM` | STARK/SNARK field mismatch; counterfeit proofs | No |
| 12 | 2023 | ZK Email | Ethereum | `CIRCUIT` | Email address spoofing in ZK identity apps | No |
| 13 | Feb 2024 | Tornado Cash | Ethereum | Supply Chain | Deposit notes leaked; 1 deposit stolen | Yes — minimal |
| 14 | Apr 2025 | ZKSync Era | Ethereum | `OPSEC` | ~$5M airdrop tokens stolen | Yes — ~$5M |

---

## Key Resources

### Primary References

- **0xPARC ZK Bug Tracker** (canonical community reference): https://github.com/0xPARC/zk-bug-tracker
- **ZKSecurity zkbugs** (reproducible PoC exploits, 110+ bugs): https://github.com/zksecurity/zkbugs
- **Trail of Bits ZK blog**: https://blog.trailofbits.com/categories/zero-knowledge/
- **ZKDocs** (attack patterns & proof system docs): https://www.zkdocs.com/
- **SoK: What Don't We Know? Understanding Security Vulnerabilities in SNARKs** (academic paper): https://eprint.iacr.org/2022/1530
- **ZKV Security Vulnerabilities overview**: https://zkv.xyz/security-vulnerabilities-in-zk/
- **Awesome ZKP Security** (curated links): https://github.com/StefanosChaliasos/Awesome-ZKP-Security

### Per-Exploit

| Exploit | Link |
|---------|------|
| Tornado Cash circuit bug (2019) | https://tornado-cash.medium.com/tornado-cash-got-hacked-by-us-b1e012a3c9a8 |
| Zcash BCTV14 | https://z.cash/blog/zcash-counterfeiting-vulnerability-successfully-remediated/ |
| Circom-Pairing (Veridise) | https://medium.com/veridise/circom-pairing-a-million-dollar-zk-bug-caught-early-c5624b278f25 |
| Frozen Heart Part 1 | https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/ |
| Frozen Heart — Bulletproofs | https://blog.trailofbits.com/2022/04/15/the-frozen-heart-vulnerability-in-bulletproofs/ |
| Frozen Heart — PlonK | https://blog.trailofbits.com/2022/04/18/the-frozen-heart-vulnerability-in-plonk/ |
| Polygon zkEVM (Hexens) | https://github.com/0xPolygonHermez/zkevm-rom/blob/main/audits/Hexens_Polygon_zkEVM_PUBLIC_27.02.23.pdf |
| Polygon zkEVM (Verichains) | https://blog.verichains.io/p/discovering-and-fixing-a-critical |
| Tornado Cash governance (2023) | https://www.halborn.com/blog/post/explained-the-tornado-cash-hack-may-2023 |
| ZKSync airdrop (2025) | https://www.halborn.com/blog/post/explained-the-zksync-hack-april-2025 |

---

*Compiled from public disclosures, audit reports, and the 0xPARC ZK Bug Tracker community database.*
